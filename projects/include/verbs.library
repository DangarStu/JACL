# --- JACL INCLUDE FILE: verbs.library
# Copyright (c) Stuart Allen 1992-2010.

#include "english.library"

constant	library_version		27

filter the
filter a

integer COUNTER
integer INDEX
integer TEMP
integer RETURN_VALUE
integer OXYGEN_LEFT
integer direction

synonym onto            on
synonym into            in
synonym inside          in
synonym using           with
synonym gentleman       man

synonym one				1
synonym two				2
synonym three			3
synonym four			4
synonym five			5
synonym six				6
synonym seven			7
synonym eight			8
synonym nine			9
synonym ten				10
synonym eleven			11
synonym twelve			12
synonym thirteen		13
synonym fourteen		14
synonym fifteen			15
synonym sixteen			16
synonym seventeen		17
synonym eighteen		18
synonym nineteen		19
synonym twenty			20

synonym taje            take
synonym taek            take
synonym all             everything
synonym speak           talk
synonym depress         press
synonym w               west
synonym e               east
synonym s               south
synonym se              southeast
synonym sw              southwest
synonym n               north
synonym ne              northeast
synonym nw              northwest
synonym u               up
synonym d               down
synonym l               look
synonym beneath         under

integer_array available_exits 12 0
string dir_command north south east west northeast northwest
string dir_command southeast southwest up down in out

grammar about >about

{+about
style note
write game_title
style normal
write ", Copyright (c) " game_author "^"
write "Release " game_release " / build " game_build 
write " / JACL verb.library version " library_version "^^"
}

constant NO_GO 22000

grammar exits >exits

{+exits
execute "+calculate_exits"
write "You can go "
if INDEX = 0 
   write "nowhere!^"
   set time = false
   return true
endif
set COUNTER = 0
repeat
   if available_exits[COUNTER] != nowhere
      hyperlink dir_command[COUNTER] dir_command[COUNTER]
      if available_exits[COUNTER] has KNOWN
         write " to " available_exits[COUNTER]{the}
      endif
      set INDEX - 1
      execute "+or_structure"
   endif
   set COUNTER + 1
until COUNTER = 12
write ".^"
set time = false
}

{+calculate_exits
execute "+clear_list"
# LOOP THROUGH ALL THE EXITS OF THE CURRENT LOCATION
set COUNTER = 0
set INDEX = 0
repeat
   ifall here(COUNTER) != nowhere : here(COUNTER) != NO_GO : +in_list<here(COUNTER) = false
      set available_exits[COUNTER] = here(COUNTER)
      set INDEX + 1 # THIS IS COUNTING THE NUMBER OF EXITS FOR PUNCTUATION
   else
      set available_exits[COUNTER] = 0
   endif
   set COUNTER + 1
until COUNTER = 12
}

{+in_list
set TEMP = 0
repeat
   if available_exits[TEMP] = arg[0]
      return true
   endif
   set TEMP + 1
until TEMP = 12
return false
}

{+clear_list
set TEMP = 0
repeat
   set available_exits[TEMP] = 0
   set TEMP + 1
until TEMP = 12
}

{+darkness
if here has DARKNESS
   execute "+no_light"
   return true
endif
return false
}

{+can_talk
if here has UNDER_WATER
   write "Talking under water isn't very easy.^"
   set time = false
   return true
endif
if arg[0] = player
   write "It's the first sign of madness you know...^"
   set time = false
   return true
endif
if arg[0] hasnt ANIMATE
   write "I don't think talking to " arg[0]{the} " is going to help "
   write "somehow.^"
   set time = false
   return true
endif
if arg[0] has DEAD
   write  arg[0]{The} " " arg[0]{is} " a bit too dead to respond.^"
   set time = false
   return true
endif
return false
}

{+important
if arg[0] has NOT_IMPORTANT
   write  arg[0]{The} " " arg[0]{is} " not important; you don't need to "
   write "worry about " arg[0]{obj} ".^"
   set time = false
   return true
endif
return false
}

{+reach
if arg[0] has OUT_OF_REACH
   write  arg[0]{The} " " arg[0]{is} " out of reach.^"
   set time = false
   return true
endif
return false
}

{+possessed
set INDEX grandof noun1
ifall INDEX has ANIMATE : INDEX != player : noun1 != INDEX
   write INDEX{The} " refuse" INDEX{s} " to give you " noun1{the} .^
   set time = false
   return true
else
   return false
endif
}

# Open an object if possible in order to perform typed command.
{+closed
if arg[0] hasnt CLOSED
   return false
endif
proxy "open " arg[0]{names}
if arg[0] has CLOSED
   set time = false
   return true
endif
return false
}

# Stop wearing an object if possible in order to perform typed command.
{+worn
if arg[0] hasnt WORN
   return false
endif
proxy "remove " arg[0]{names}
if arg[0] has WORN
   set time = false
   return true
endif
return false
}

# Take an object if possible in order to perform typed command.
{+not_held
if arg[0] is *held
   return false
endif
proxy "take " arg[0]{names}
if arg[0] isnt *held
   set time = false
   return true
endif
return false
}

location limbo : limbo

grammar shake >shake_only

{+shake_only
write "Scared?^"
set time = false
}

grammar shake *held   >shake
grammar wave *held    >shake

{+shake
if +not_held<noun1 = true
   return
endif
write "Consider it done.^"
}

grammar say xyzzy >xyzzy
grammar xyzzy     >xyzzy

{+xyzzy
set time = false
if @+xyzzy != 1
   write "~Go away. Leave us alone.~^"
   return true
endif
write "~That's the password, open the door.~^^"
write "~Are you sure? I don't recognise the voice.~^^"
write "~Don't argue, just open the door!~^^"
write "A previously-invisible door swings open. Beyond the door you "
write "see what you can only imagine to be God's workshop.^^"
write "write ~Shit! I told you it wasn't him!" caret "~;^" 
write "set bouncer_1(panic) + 5;^"
write "write ~Quick! Shut the door." caret "~;^"
write "set poo(parent) = bouncer_2s_trousers;^"
write "ensure magic_door has CLOSED;^"
write "^The door shuts and disappears again. Something tells you it "
write "is going to be one of those days...^"
}

grammar save $string >named_save

{+named_save
savegame INDEX $string
if INDEX = true
   write "Game saved.^"
endif
set time = false
}

grammar restore $string >named_restore

{+named_restore
restoregame INDEX $string
if INDEX = true
   write "Restored saved game.^^"
   ensure here hasnt VISITED
   execute "+display_location"
endif
set time = false
}

string filename

{+load_saved
repeat
   write "Would you like to restore a saved game?^"
   getyesorno TEMP
   if TEMP = true
       restoregame INDEX
       if INDEX = true
          write "Restored saved game.^^"
   		  ensure here hasnt VISITED
          execute "+display_location"
          return true
       endif
   endif
until TEMP = false
return false
}

grammar save >save_game

{+save_game
savegame INDEX
if INDEX = true
   write "Game saved.^"
endif
set time = false
}

grammar restore >restore_game

{+restore_game
restoregame INDEX
if INDEX = true
   write "Restored saved game.^^"
   ensure here hasnt VISITED
   execute "+display_location"
endif
set time = false
}

grammar status on >status_on

{+status_on
if status_window = 1
write "The status window is already turned on.^"
else
set status_window = 1
write "Status window turned on.^"
endif
set time = false
}

grammar status off >status_off

{+status_off
if status_window = 0
write "The status window is already turned off.^"
else
set status_window = 0
write "Status window turned off.^"
endif
set time = false
}

grammar sound on >sound_on

{+sound_on
if sound_enabled = true
write "Sound is already enabled.^"
else
set sound_enabled = true
write "Sound enabled.^"
endif
set time = false
}

grammar sound off >sound_off

{+sound_off
if sound_enabled = false
write "Sound is already disabled.^"
else
set sound_enabled = false
write "Sound disabled.^"
stop 0
stop 1
stop 2
stop 3
endif
set time = false
}

grammar graphics on >graphics_on

{+graphics_on
if graphics_enabled = true
write "Graphics are already enabled.^"
else
set graphics_enabled = true
write "Graphics enabled.^"
endif
set time = false
}

grammar graphics off >graphics_off

{+graphics_off
if graphics_enabled = false
write "Graphics are already disabled.^"
else
set graphics_enabled = false
write "Graphics disabled.^"
endif
set time = false
}

grammar timer on >timer_on

{+timer_on
if timer_enabled = true
write "The timer is already enabled.^"
else
set timer_enabled = true
write "Timer enabled.^"
endif
set time = false
}

grammar timer off >timer_off

{+timer_off
if timer_enabled = false
write "The timer is already disabled.^"
else
set timer_enabled = false
write "Timer disabled.^"
endif
set time = false
}

grammar verbose >verbose

{+verbose
if display_mode = 1
   write "Display mode already set to verbose.^"
   set time = false
   return true
endif
write "Display mode set to verbose.^^"
set display_mode = 1
look
set time = false
}

grammar brief >brief

{+brief
if display_mode = 0
   write "Display mode already set to brief.^"
   set time = false
   return true
endif
write "Display mode set to brief.^"
set display_mode = 0
set time = false
}

grammar help *present           >help_other

{+help_other
write "How did you intend to help " noun1{the} ?^
}

grammar hint *present	>hint_nonum
grammar hint			>hint_nonum

{+hint_nonum
if noun1 = false
   proxy "hint 1"
else
   proxy "hint 1 " noun1{names} 
endif
}

grammar hint $integer *present	>hint
grammar hint $integer			>hint

{+hint
if noun1 = false
   write "There are no hints available for this location.^"
else
   write "There are no hints available for " noun1{the} .^
endif
set time = false
}

grammar help games >help_games

{+help_games
write "`GAMES' REFERS TO MODELS, SIMULATIONS AND GAMES WHICH HAVE TACTICAL "
write "AND STRATEGIC APPLICATIONS.^"
}

grammar hug			>hug_only
grammar comfort		>hug_only
grammar cuddle		>hug_only
grammar console		>hug_only

{+hug_only
if +get_animate != 0
   proxy "hug " candidate{names}
   return
endif
write "Who did you want to hug?^"
setstring question "hug "
set time = false
}

grammar hug *present     >hug
grammar comfort *present >hug
grammar cuddle *present  >hug
grammar console *present >hug

{+hug
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
if noun1 hasnt ANIMATE
   write "Odd.^"
   return true
endif
write "I'm sure " noun1{the} " feel" noun1{s} " a whole lot better now.^"
}

grammar kiss	>kiss_only
grammar pash	>kiss_only
grammar snog	>kiss_only

{+kiss_only
if +get_animate != 0
   proxy "kiss " candidate{names}
   return
endif
write "Who did you want to kiss?^"
setstring question "kiss "
set time = false
}

grammar kiss *present >kiss
grammar pash *present >kiss
grammar snog *present >kiss

{+kiss
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
write "Hmmmmmm...^"
}

grammar dig *present			>dig_in
grammar dig in *present			>dig_in
grammar dig up *present			>dig_in
grammar dig through *present	>dig_in
grammar dig thru *present		>dig_in

{+dig_in
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
write "You can't dig in " noun1{the} ".^"
set time = false
}

grammar dig >dig

{+dig
if here hasnt OUTDOORS
   print:
      You can't dig in here.^
   .
else
   print:
      There is no need to dig here.^
   .
endif
set time = false
}

grammar pick >pick_only

{+pick_only
write "What did you want to pick?^"
setstring question "pick "
set time = false
}

grammar pick *present >pick_one

{+pick_one
if +get_dropable != 0
   proxy "pick " noun1{the} " with " candidate{names}
   return
endif
write "What did you want to pick " noun1{the} " with?^"
setstring question "pick " noun1{the} " with "
set time = false
}

grammar pick *present with *held >pick_with

{+pick_with
if +not_held<noun2 = true
   return
endif
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
write "You can't pick " noun1{the} " with " noun2{the} .^
}

grammar rub *present    >rub
grammar pat *present    >rub

{+rub
if +important<noun1 = true
   return true
endif
if +darkness = true 
   return true
endif
if +reach<noun1 = true
   return true
endif
override
write "I'm sure " noun1{the} " " noun1{is} " feeling a lot better now.^"
}

grammar rub *held on *present         >rub_on

{+rub_on
if +not_held<noun1 = true
   return
endif
if +important<noun2 = true
   return true
endif
if +darkness = true
   return true
endif
override
proxy "rub " noun2{names} " with " noun1{names}
}

grammar rub *present with *held    >rub_with

{+rub_with
if +not_held<noun2 = true
   return
endif
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
write "They both just get a little warmer.^"
}

grammar lick *present  >lick
grammar taste *present >lick

{+lick
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
write "Yeuucck!^"
}

grammar pull **present >pull
grammar tug **present  >pull

{+pull
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
write "You can't pull " noun1{the} .^
}

grammar cut *present  >cut
grammar chop *present >cut
grammar stab *present >cut

{+cut
write "What did you want to cut " noun1{the} " with?^"
setstring question "cut " noun1{names} " with "
set time = false
}

grammar cut *present with *held       >cut_with
grammar chop *present with *held      >cut_with
grammar stab *present with *held      >cut_with

{+cut_with
if +not_held<noun2 = true
   return
endif
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
if noun1 has ANIMATE
   proxy "attack " noun1{names} " with " noun2{names}
   return true
endif
write "Vandal!^"
set time = false
}

grammar peel *present		>peel
grammar skin *present		>peel

{+peel
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
write "You can't peel " noun1{the} ".^"
set time = false
}

grammar break *present		>break
grammar smash *present		>break
grammar crush *present		>break
grammar destroy *present	>break
grammar wreck *present		>break
grammar crack *present		>break
grammar tear **present		>break
grammar tear up **present	>break
grammar tear **present up	>break
grammar tear off **present	>break
grammar tear **present off	>break
grammar rip **present		>break
grammar rip up **present	>break
grammar rip **present up	>break
grammar rip off **present	>break
grammar rip **present off	>break

{+break
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
if noun1 has ANIMATE
   write "Don't be so aggressive.^"
else
   write "Don't be so destructive.^"
endif
set time = false
}

grammar clean *present        >clean
grammar wash *present         >clean
grammar wipe *present         >clean
grammar scrub *present        >clean
grammar polish *present       >clean

{+clean
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
if noun1 has LIQUID
   write "How do you clean a liquid?^"
   set time = false
   return true
endif
override
write "That's very thoughtful of you.^"
}

grammar clean *present with *held     >clean_with
grammar wipe *present with *held      >clean_with
grammar scrub *present with *held     >clean_with
grammar brush *present with *held     >clean_with

{+clean_with
if +not_held<noun2 = true
   return
endif
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
if noun1 has LIQUID
   write "How do you clean a liquid?^"
   set time = false
   return true
endif
override
write "You can't clean " noun1{the} " with " noun2{the} .^
set time = false
}

grammar yell at *present      >yell_at
grammar scream at *present    >yell_at

{+yell_at
write "Oooo, scary...^"
}

grammar yell      >yell
grammar scream    >yell

{+yell
write "Your throat is now sore.^"
}

grammar pay *present       >pay

{+pay
write "You can't pay " noun1{the} .^
}

grammar order *anywhere       >order
grammar buy *anywhere         >order

{+order
write "Your order appears to have fallen on deaf ears.^"
}

grammar knock on *present     >knock_on
grammar tap on *present       >knock_on
grammar tap *present          >knock_on

{+knock_on
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
if noun1 has ANIMATE
   proxy "attack " noun1{names}
   endif
endif
if noun1 has LIQUID
   write "A wet hand is your only reward.^"
   return true
endif
write "You gently tap on " noun1{the}.^"
}

grammar smoke *present >smoke

{+smoke
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
write "You can't smoke " noun1{the} .^
set time = false
}

grammar play *present	>play
grammar sound *present	>play
grammar ring *present	>play

{+play
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
write "You can't play " noun1{the} .^
set time = false
}

grammar play *present with *held	>play_with
grammar sound *present with *held	>play_with
grammar ring *present with *held	>play_with

{+play_with
if +not_held<noun2 = true
   return
endif
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
write "You can't play " noun1{the} " with " noun1{the} .^
set time = false
}

grammar pump *present >pump

{+pump
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
write "You can't pump " noun1{the} .^
set time = false
}

grammar unload *here    >empty
grammar empty *here     >empty

{+empty
proxy "take all from " noun1{names}
}

grammar extract **here with *held	>take_with
grammar get **here with *held		>take_with
grammar take **here with *held		>take_with
grammar take out **here with *held	>take_with
grammar hold **here with *held		>take_with
grammar empty **present with *held	>take_with

{+take_with
if +not_held<noun2 = true
   return
endif
proxy "fill " noun2{names} " with " noun1{names}
}

grammar fill *held from *present      >fill_from

{+fill_from
if +not_held<noun1 = true
   return
endif
if +important<noun2 = true
   return true
endif
if +darkness = true
   return true
endif
if +contains_liquid?<noun2 == false
   write  noun2{The} " " noun2{doesnt} "contain a liquid to fill " noun1{the}
   write " with.^"
   set time = false
   return true
endif
proxy "fill " noun1{names} " with " CHILD{names}
}

grammar fill *held with *present >fill_with

{+fill_with
if +not_held<noun1 = true
   return
endif
if +important<noun2 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun2 = true
   return true
endif
if noun2 hasnt LIQUID 
   if +contains_liquid?<noun2 = true
      set noun2 = CHILD
   else
      write "You can only fill " noun1{the} " with a liquid.^"
      return true
   endif
endif
if noun1 hasnt CONTAINER
   write  noun1{The} " " noun1{isnt} " a container and therefore can't be "
   write "filled.^"
   return true
endif
if noun1 has CLOSED
   write "You can't fill " noun1{the} " while "
   if noun1 has PLURAL
      write "they are"
   else
      write "it is"
   endif
   write " closed.^"
   set time = false
   return true
endif
if +contains_liquid?<noun1 = true
   write  noun1{The} " already contains " CHILD{the} ". If you were to also "
   write "add " noun2{the} " they would mix together.^"
   set time = false
   return true
endif
if noun1(quantity) < noun2(mass)
   write  noun1{The} " " noun1{isnt} " large enough to hold " 
   write noun2{the} .^
   set time = false
   return true
endif
override
write "You fill " noun1{the} " with " noun2{the} .^
move noun2 to noun1
}

{+contains_liquid?
# CHECK IF THE SPECIFIED OBJECT CONTAINS ANY LIQUIDS
select LIQUID CHILD
   if CHILD(parent) = arg[0]
      return true
   endif
endselect
return false
}

grammar fill *held >fill

{+fill
if +important<noun1 = true
   return true
endif
if +not_held<noun1 = true
   return
endif
if +darkness = true
   return true
endif
override
write "What did you want to fill " noun1{the} " with?^"
setstring question "fill " noun1{names} " with "
set time = false
}

grammar stand         >stand
grammar stand up      >stand
grammar get up        >stand

{+stand
if player has SITTING
   write "Using your arms to push yourself up, you stand.^"
   ensure player hasnt SITTING
   return true
endif
write "You are already standing.^"
}

grammar sleep         >sleep

{+sleep
write "There will be plenty of time for that later...^"
set time = false
}

grammar lie on *present       >lie_on
grammar lie down on *present  >lie_on
grammar sleep on *present     >lie_on
grammar sleep in *present     >lie_on

{+lie_on
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
write  noun1{The} " " noun1{doesnt} " look like the ideal place to take a "
write "nap.^"
}

grammar sit			>sit
grammar sit down	>sit
grammar squat		>sit
grammar squat down	>sit

{+sit
set time = false
if player has SITTING
   write "You are already sitting.^"
   return true
endif
if here has UNDER_WATER
   write "While underwater?^"
   return true
endif
if here has ON_WATER
   write "While in water?^"
   return true
endif
write "You plonk yourself down for a moment's rest.^"
ensure player has SITTING
}

grammar sit *here	  >sit_on
grammar sit on *here  >sit_on
grammar sit in *here  >sit_on

{+sit_on
if +important<noun1 = true
   return true
endif
if noun1 is *held
   write "Is is hard to sit on something while you are holding it.^"
   set time = false
   return
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
write  noun1{The} " " noun1{doesnt} " look very comfortable.^"
}

grammar kick *present           >kick

{+kick
if +worn<noun1 = true
   return true
endif
override
if noun1 has ANIMATE
   proxy "attack " noun1{names}
   return
endif
if noun1(mass) = scenery
   if noun1 grandof player
      write "That act of contortion is beyond you.^"
      set time = false
      return
   else
      proxy "attack " noun1{names}
      return
   endif
endif
write "You kick " noun1{the} " a short distance away.^"
move noun1 to here
}

grammar throw *held	>throw
grammar lob *held	>throw
grammar hurl *held	>throw
grammar pitch *held	>throw
grammar cast *held	>throw

{+throw
if +not_held<noun1 = true
   return
endif
if +move_scenery<noun1 = true
   return true
endif
if +worn<noun1 = true
   return true
endif
override
if here has MID_WATER : here has ON_WATER
   write "You throw " noun1{the} " which rapidly sink" noun1{s} " out of "
   write "view.^"
   move noun1 to limbo
   return true
endif
write "You throw " noun1{the} " a short distance away.^"
move noun1 to here
}

grammar drop 		>drop_only
grammar put down	>drop_only

{+drop_only
if +get_dropable != 0
   proxy "drop " candidate{names}
   return
endif
write "What did you want to drop?^"
setstring question "drop "
set time = false
}

grammar drop **held		>drop
grammar put **held down	>drop
grammar put down **held	>drop

{+drop
if noun1 isnt *held
   write "You aren't carrying " noun1{the} ".^"
   set time = false
   return
endif
if +move_scenery<noun1 = true
   return true
endif
if +worn<noun1 = true
   return true
endif
override
if here has MID_WATER : here has ON_WATER
   write "You drop " noun1{the} " which rapidly sink" noun1{s} " out of "
   write "view.^"
   move noun1 to limbo
   return true
endif
write "You drop " noun1{the} .^
move noun1 to here
}

grammar take 		>take_only
grammar take out	>take_only
grammar hold 		>take_only
grammar pick		>take_only
grammar pick		>take_only
grammar get			>take_only

{+take_only
if +get_takeable != 0
   proxy "take " candidate{names}
   return
endif
write "What did you want to take?^"
setstring question "take "
set time = false
}

grammar take **here		>take
grammar take out **here	>take
grammar hold **here		>take
grammar pick up **here	>take
grammar pick **here up	>take
grammar get **here		>take

{+take
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
if +possessed<noun1 = true
   return
endif
if noun1 is *held
   write "You are already holding " noun1{the} ".^"
   set time = false
   return
endif
if player has SITTING
   write "You will have to stand up first.^"
   set time = false
   return true
endif
if noun1 has ANIMATE
   write "I don't think " noun1{sub} " would appreciate that.^"
   set time = false
   return true
endif
if +move_scenery<noun1 = true
   return true
endif
if noun1(mass) > player(quantity)
   write "You are carrying too much to take " noun1{the} .^
   set time = false
   return true
endif
if noun1 has LIQUID
   write  noun1{The} " run" noun1{s} " through your fingers.^"
   return true
endif
override
write "You take " noun1{the} .^
move noun1 to player
ensure noun1 has TOUCHED
}

{+move_scenery
if arg[0] has LOCATION
   write "That would be an impressive feat of strength.^"
   set time = false
   return true
endif
if arg[0](mass) => heavy
   set noun3 = noun1(parent)
   set INDEX = noun3
   if noun3 has LOCATION
      write "You can't take " noun1{the} ".^"
      return true
   else
      write noun1{The} " " noun1{is} " attached to " noun3{the} .^
   endif
   set time = false
   return true
endif
return false
}

grammar insert **held on *present	>insert_on
grammar put **held on *present		>insert_on
grammar place **held on *present	>insert_on

{+insert_on
if +important<noun2 = true
   return true
endif
if +not_held<noun1 = true
   return
endif
if +darkness = true
   return true
endif
if +reach<noun2 = true
   return true
endif
if noun2 = noun1
   write "Put " noun1{the} " on "
   if noun1 has PLURAL
      write "themselves?"
   else
      write "itself?"
   endif
   write " I don't think so.^"
   set time = false
   return true
endif
if noun2(parent) = noun1
   write "I'm afraid that's just not possible.^"
   set time = false
   return true
endif
if +move_scenery<noun1 = true
   return true
endif
if noun2 hasnt SURFACE
   write "There isn't a flat surface on " noun2{the} .^
   set time = false
   return true
endif
if noun2(quantity) < noun1(mass)
   write "There is not enough room on " noun2{the} " for " noun1{the} .^
   set time = false
   return true
endif
if +worn<noun1 = true
   return true
endif
override
write "You put " noun1{the} " on " noun2{the} .^
move noun1 to noun2
}

grammar insert **held under *present	>insert_under
grammar put **held under *present		>insert_under
grammar place **held under *present		>insert_under

{+insert_under
if +important<noun2 = true
   return true
endif
if +not_held<noun1 = true
   return
endif
if +darkness = true
   return true
endif
if +reach<noun2 = true
   return true
endif
if noun2 = noun1
   write "Put " noun1{the} " under "
   if noun1 has PLURAL
      write "themselves?"
   else
      write "itself?"
   endif
   write " I don't think so.^"
   set time = false
   return true
endif
if +move_scenery<noun1 = true
   return true
endif
override
proxy "drop " noun1{names}
}

grammar insert **held in *present	>insert_in
grammar put **held in *present		>insert_in
grammar place **held in *present	>insert_in

{+insert_in
if +important<noun2 = true
   return true
endif
if +not_held<noun1 = true
   return
endif
if +darkness = true
   return true
endif
if +reach<noun2 = true
   return true
endif
if +move_scenery<noun1 = true
   return true
endif
if noun2 = noun1
   write "Put " noun1{the} " in "
   if noun1 has PLURAL
      write "themselves?"
   else
      write "itself?"
   endif
   write " I don't think so.^"
   set time = false
   return true
endif
if noun2(parent) = noun1
   write "I'm afraid that's just not possible.^"
   set time = false
   return true
endif
if noun2 = player
   write "I would ask how you intend to do that, but something tells me I "
   write "don't want to know.^"
   set time = false
   return true
endif
if noun2 hasnt CONTAINER
   write noun2{The} " " noun2{isnt} " designed to receive " 
   write noun1{the} .^
   set time = false
   return true
endif
if +closed<noun2 = true
   return true
endif
if noun2(quantity) < noun1(mass)
   write "There is not enough room in " noun2{the} " for " noun1{the} .^
   set time = false
   return true
endif
if +worn<noun1 = true
   return true
endif
override
write "You put " noun1{the} " in " noun2{the} .^
move noun1 to noun2
}

{+encumbered
if INDEX = 0
   write "You are not carrying anything.^"
   set time = false
endif
}

grammar ask *present for **inside			>ask_for
grammar tell *present to give me **inside	>ask_for

{+ask_for
if +can_talk<noun1 = true
   return true
endif
if noun1 !grandof noun2
   write  noun1{The} " " noun1{doesnt} " seem to have " noun2{the} .^
   set time = false
   return true
endif
if +possessed<noun1 = true
   return
endif
if noun2(mass) > player(quantity)
   write "With your current load you would be unable to accept "
   write noun2{the} .^
   set time = false
   return true
endif
override
move noun2 to player
if noun2 has WORN
   write  noun1{The} " remove" noun1{s} " " noun2{the} " then hand" noun1{s}
   if noun2 has PLURAL
      write " them"
   else
      write " it"
   endif
   write " to you.^" 
   ensure noun2 hasnt WORN
   return true
endif
write  noun1{The} " hands you " noun2{the} .^
}

grammar tell *present about *anywhere		>tell_about
grammar talk to *present about *anywhere	>tell_about
grammar talk *present about *anywhere		>tell_about
grammar talk with *present about *anywhere	>tell_about

{+tell_about
if +can_talk<noun1 = true
   return true
endif
override
write  noun1{The} " seem" noun1{s} " fascinated by your story about "
write noun2{the} .^
}

grammar ask *present about *anywhere  >ask_about

{+ask_about
if +can_talk<noun1 = true
   return true
endif
override
if noun2 = noun1
   write noun1{The}
   if noun1 has PLURAL
      write " are too shy to say much.^"
   else
      write " is too shy to say much.^"
   endif
   return true
endif
write noun1{The} " " noun1{doesnt} " have anything to say about " noun2{the}
write ".^"
}

grammar offer *held to *present			>give_to
grammar give *held to *present			>give_to
grammar give *held over to *present		>give_to
grammar pass *held to *present			>give_to
grammar pass *held up to *present		>give_to
grammar pass *held down to *present		>give_to
grammar pass *held over to *present		>give_to
grammar hand *held to *present			>give_to
grammar hand *held up to *present		>give_to
grammar hand *held down to *present		>give_to
grammar hand *held over to *present		>give_to
grammar heave *held to *present			>give_to
grammar heave *held up to *present		>give_to
grammar heave *held over to *present	>give_to
grammar lower *held down to *present	>give_to

{+give_to
if +not_held<noun1 = true
   return
endif
if noun2 hasnt ANIMATE
   write "You can't give " noun1{the} " to " noun2{the} .^
   set time = false
   return true
endif
if noun2 = player
   write "I think it might be time to take a break and get a cup of "
   write "tea.^"
   return true
endif
if +reach<noun2 = true
   return true
endif
if +move_scenery<noun1 = true
   return true
endif
if +worn<noun1 = true
   return true
endif
override
move noun1 to noun2
write "You give " noun1{the} " to " noun2{the} .^
}

grammar offer *held		>give_only
grammar give *held		>give_only
grammar give *held		>give_only
grammar pass *held		>give_only
grammar pass *held		>give_only
grammar pass *held		>give_only
grammar pass *held		>give_only
grammar hand *held		>give_only
grammar hand *held		>give_only
grammar hand *held		>give_only
grammar hand *held		>give_only
grammar heave *held		>give_only
grammar heave *held		>give_only
grammar heave *held		>give_only

{+give_only
if +get_animate != 0
   proxy "give " noun1{names} " to " candidate{names}
   return
endif
write "Who did you want to give " noun1{the} " to?^"
setstring question "give " noun1{names} " to "
set time = false
}

grammar wiggle *present	>move
grammar jiggle *present	>move
grammar move *present	>move
grammar push *present	>move

{+move
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
if player has SITTING
   write "You will have to stand up first.^"
   set time = false
   return true
endif
if +move_scenery<noun1 = true
   return true
endif
if noun1 has LIQUID
   write  noun1{The} " run" noun1{s} " through your fingers.^"
   return true
endif
if noun1(parent) = player
   override
   write "You juggle " noun1{the} " in your hands.^"
   return true
endif
if +worn<noun1 = true
   return true
endif
override
write "You move " noun1{the} " a short distance to one side.^"
ensure noun1 has TOUCHED
}

grammar read *present >read

{+read
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
write "There is nothing on " noun1{the} " to read.^"
}

grammar look down >look_down

{+look_down
if +darkness = true
   return true
endif
if here has TIGHT_ROPE : here has MID_AIR
   write "You see the ground far below.^"
   return true
endif
if here has ON_WATER
   write "You can't see beyond the surface of the water.^"
   return true
endif
write "You take a moment to admire your investigating feet.^"
}

grammar look up >look_up

{+look_up
if +darkness = true
   return true
endif
override
if here hasnt OUTDOORS
   write "You see nothing special.^"
else
   write "You see just sky.^"
endif
}

grammar look up *anywhere in *present         >look_up_in
grammar look for *anywhere in *present        >look_up_in

{+look_up_in
if +important<noun1 = true
   return true
endif
if +important<noun2 = true
   return true
endif
if +darkness = true
   return true
endif
write "You don't find any reference to " noun1{the} " in " noun2{the} .^
}

grammar consult *present about *anywhere      >consult
grammar consult *present re *anywhere         >consult
grammar consult *present on *anywhere         >consult

{+consult
proxy "look up " noun2{names} " in " noun1{names}
}

grammar feel *present  >feel
grammar touch *present >feel

{+feel
if +reach<noun1 = true
   return true
endif
if noun1 has ANIMATE
   write "I'm not so sure that would be polite.^"
   return true
endif
write "Feels just like " noun1{list} .^
}

grammar smell		>sniff
grammar sniff		>sniff

{+sniff
if here has UNDER_WATER
   write "You can't smell anything while you are underwater.^"
   return
endif
write "You don't smell anything out of the ordinary.^"
}

grammar smell *present	>smell
grammar sniff *present	>smell

{+smell
if here has UNDER_WATER
   write "You can't smell anything while you are underwater.^"
   return
endif
if noun1 has ANIMATE
   write "I'm not so sure that would be polite.^"
   return true
endif
write "Smells an awful lot like " noun1{list} .^
}

grammar taste *present >taste
grammar lick *present  >taste

{+taste
if +reach<noun1 = true
   return true
endif
if noun1 has ANIMATE
   write "You are one sick puppy.^"
   return true
endif
write "Tastes just like you would expect " noun1{list} " to taste.^"
}

grammar look in *present      >look_in

{+look_in
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if noun1 hasnt CONTAINER
   write "There is nothing in " noun1{the} .^
   return true
endif
if noun1 has CLOSED
   write  noun1{The} " " noun1{is} " currently closed.^"
   return true
endif
set INDEX = +child_count<noun1
if INDEX = 0
   write "There is nothing in " noun1{the} .^
   return true
endif
execute "+details<noun1"
write "^"
}

grammar search *present		>search

{+search
ifexecute "noun1.search"
   return
endif
if noun1 has ANIMATE
   write "I'm not so sure that would be polite.^"
   return true
endif
proxy "examine " noun1{names}
}

grammar look *present		>examine
grammar look at *present	>examine
grammar l at *present		>examine
grammar look on *present	>examine
grammar examine *present	>examine
grammar x *present			>examine
grammar l *present			>examine
grammar watch *present		>examine

{+examine
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
override
if noun1 has LOCATION
   proxy "look"
   return
endif
ifall noun1 hasnt CLOSABLE : noun1 hasnt CONTAINER : noun1 hasnt SURFACE
   write "There is nothing special about " noun1{the} .^
   return true
endif
if noun1 has CLOSABLE
   execute "+details<noun1"
   write "^"
   return true
endif
set INDEX = 0
select noun1
   if noun3(mass) != scenery
      set INDEX + 1
   endif
endselect
if INDEX = 0
   write "There is nothing special about " noun1{the} .^
   return true
endif
execute "+details<noun1"
write "^"
}

{+details
if arg[0] has CLOSABLE 
   if arg[0] hasnt CLOSED
      write  noun1{The} " " arg[0]{is} " open"
   else
      write  noun1{The} " " arg[0]{is} " closed."
      return true
   endif
endif
if arg[0] has CONTAINER : arg[0] has SURFACE
   execute "+contents<arg[0]"
endif
}

{+contents
set INDEX = +child_count<arg[0]
if INDEX = 0 : arg[0] has CONCEALING 
   ifall arg[0] has CONTAINER : arg[0] has CLOSABLE
      write "."
   endif
   return true
endif
execute "+list_items<arg[0]"
}

{+clean_contents
set INDEX = 0
select arg[0]
   if noun3(mass) != scenery
      set INDEX + 1
   endif
endselect
if INDEX = 0 : arg[0] has CONCEALING 
   return true
endif
execute "+list_items<arg[0]"
}

{+list_items
if INDEX = 0 : arg[0] has CONCEALING
   return true
endif
if arg[0] has ANIMATE
   write arg[0]{The} " " arg[0]{is} " carrying "
endif
if arg[0] has SURFACE
   write "On " arg[0]{the} " is " 
endif
if arg[0] has CONTAINER
   if arg[0] has CLOSABLE
      write " and contains "
   else
      write arg[0]{The} " contains "
   endif
endif
select arg[0] CHILD
   if CHILD(mass) != scenery
      set INDEX - 1
      write CHILD{list}
      execute "+object_info<CHILD"
      execute "+list_structure"
      if INDEX = 0
	     return true
      endif
   endif
endselect
}

{+spaced_contents
set INDEX = 0
select arg[0]
   if noun3(mass) != scenery
      set INDEX + 1
   endif
endselect
if INDEX = 0
   return true
endall
write "^"
execute "+list_items<arg[0]"
write "^"
}

integer CHILD

{+first_child
select arg[0] CHILD
   return true
endselect
return false
}

{+child_count
set INDEX = 0
select arg[0] CHILD
   if CHILD(mass) != scenery
      set INDEX + 1
   endif
endselect
return INDEX
}

grammar i   >list_inventory
grammar list  >list_inventory

integer INVENTORY

{+list_inventory
set INDEX = 0
select player
   if noun3(mass) != scenery
      set INDEX + 1
   endif
endselect
if INDEX = 0
   write "You are empty-handed.^"
   return true
endif
write "You are carrying:^"
select player INVENTORY
   if INVENTORY(mass) != scenery
      if interpreter = GLK
         write "  " INVENTORY{list}
      else
         write "&nbsp;&nbsp;" INVENTORY{list}
      endif
      execute "+object_info<INVENTORY"
      if INVENTORY has CONTAINER : INVENTORY has SURFACE
         ifall INVENTORY hasnt CLOSED : +child_count<INVENTORY != 0
			write ", which contains:^"
	        execute "+object_children<INVENTORY"
         else
            write "^"
         endif
      else
         write "^"
	  endif
   endif
endselect
set time = false
}

integer CHILDREN

{+object_children
set INDEX = 0
select arg[0] CHILDREN
   if CHILDREN(mass) != scenery
      set INDEX + 1
      if interpreter = GLK
         write "    " CHILDREN{list}
      else
         write "&nbsp;&nbsp;&nbsp;&nbsp;" CHILDREN{list}
      endif
      execute "+object_info<CHILDREN"
      write "^"
   endif
endselect
if INDEX = 0
   if interpreter = GLK
      write "    nothing^"
   else
      write "&nbsp;&nbsp;&nbsp;nothing^"
   endif
endif
}

grammar inventory	>inventory
grammar inv			>inventory

{+inventory
set time = false
set INDEX = +child_count<player
if INDEX = 0
   write "You are empty handed.^"
   return true
endif
write "You are carrying "
select player INVENTORY
   if INVENTORY(mass) != scenery
      set INDEX - 1
      write INVENTORY{list}
      execute "+object_info<INVENTORY"
      execute "+list_structure"
      if INDEX = 0
	     write "^"
	     return true
      endif
   endif
endselect
}

{+or_structure
if INDEX > 1
   write ", "
endif
if INDEX = 1
   write " or "
endif
}

{+list_structure
if INDEX > 1
   write ", "
endif
if INDEX = 1
   write " and "
endif
if INDEX = 0
   write "."
endif
}

{+object_info
if arg[0] has WORN
   write " (being worn)"
endif
if arg[0] has LUMINOUS
   write " (providing light)"
endif
if arg[0] has ON
   write " (on)"
endif
ifall arg[0] has CLOSABLE : arg[0] hasnt CLOSED
   write " (open)"
endif
}

grammar sorry >sorry

{+sorry
write "That's quite all right.^"
}

grammar thanks        >thankyou
grammar thank you     >thankyou

{+thankyou
write "You're welcome.^"
}

grammar notify >notify

{+notify
if notify = false
   set notify = true
   write "Score notification set to on.^"
else   
   set notify = false
   write "Score notification set to off.^"
endif
set time = false
}

grammar notify on >notify_on

{+notify_on
if notify = true
    write "Score notification is already set to on.^"
else
    set notify = true
    write "Score notification set to on.^"
endif
set time = false
}

grammar notify off >notify_off

{+notify_off
if notify = false
    write "Score notification is already set to off.^"
else
    set notify = false
    write "Score notification set to off.^"
endif
set time = false
}

grammar debug >debug

{+debug
if debug = false
   set debug = true
   write "Debug messages set to on.^"
else   
   set debug = false
   write "Debug messages set to off.^"
endif
set time = false
}

grammar debug on >debug_on

{+debug_on
if debug = true
    write "Debug messages are already set to on.^"
else
    set debug = true
    write "Debug messages set to on.^"
endif
set time = false
}

grammar debug off >debug_off

{+debug_off
if debug = false
    write "Debug messages are already set to off.^"
else
    set debug = false
    write "Debug messages set to off.^"
endif
set time = false
}

grammar score >score_command
grammar points >score_command

{+score_command
execute "+score"
}

{+score
set time = false
if total_moves = 1
   write "Your score is " score "% in 1 move.^"
else
   write "Your score is " score "% in " total_moves " moves.^"
endif
}

grammar loosen	>open_only
grammar open 	>open_only

{+open_only
if +get_openable != 0
   proxy "open " candidate{names}
   return
endif
write "What did you want to open?^"
setstring question "open "
set time = false
}

grammar loosen *present	>open
grammar open *present	>open

{+open
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
if noun1 has LOCKED
   write  noun1{The} " " noun1{is} " locked.^"
   set time = false
   return true
endif
if noun1 hasnt CLOSABLE
   write "You can't open " noun1{the} .^
   set time = false
   return true
endif
if noun1 hasnt CLOSED
   write  noun1{The} " " noun1{is} " already open.^"
   set time = false
   return true
endif
override
ensure noun1 hasnt CLOSED
if noun1 has CONTAINER
   execute "+revealing"
   return true
endif
write "You open " noun1{the} .^
}

{+revealing
set INDEX = 0
select noun1
   set INDEX + 1
endselect
write "You open " noun1{the}
if INDEX = 0
   write ", which " noun1{is} " empty.^"
   return true
endif
write " revealing "
select noun1
   set INDEX - 1
   write noun3{list}
   execute "+object_info<noun3"
   execute "+list_structure"
   if INDEX = 0
      write "^"
      return true
   endif
endselect
}

grammar tighten	>close_only
grammar close	>close_only
grammar shut	>close_only

{+close_only
if +get_closable != 0
   proxy "close " candidate{names}
   return
endif
write "What did you want to close?^"
setstring question "close "
set time = false
}

grammar tighten	*present	>close
grammar close *present		>close
grammar shut *present		>close

{+close
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
if noun1 hasnt CLOSABLE
   write "You can't close " noun1{the} .^
   set time = false
   return true
endif
if noun1 has CLOSED
   write  noun1{The} " " noun1{is} " already closed.^"
   set time = false
   return true
endif
override
write "You close " noun1{the} .^
ensure noun1 has CLOSED
}

grammar lock *present >lock

{+lock
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
ifall noun1 has LOCKABLE : noun1 has LOCKED
   write  noun1{The} " " noun1{is} " already locked.^"
   return true
endif
ifall noun1 has CLOSABLE : noun1 hasnt CLOSED
   write "You can't lock " noun1{the} " while "
   if noun1 has PLURAL
      write "they are"
   else
      write "it is"
   endif
   write " open.^"
   set time = false
   return true
endif
if noun1 hasnt LOCKABLE
   write "You can't lock " noun1{the} .^
   return true
endif
override
write "What did you want to lock " noun1{the} " with?^"
setstring "lock " noun1{names} " with " 
set time = false
}

grammar lock *present with *held >lock_with

{+lock_with
if +important<noun1 = true
   return true
endif
if +not_held<noun1 = true
   return
endif
if +darkness = true
   return true
endif
if noun1 hasnt LOCKABLE
   write "You can't lock " noun1{the} .^
   set time = false
   return true
endif
if +reach<noun1 = true
   return true
endif
if noun1 has LOCKED
   write  noun1{The} " " noun1{is} " already locked.^"
   return true
endif
ifall noun1 has CLOSABLE : noun1 hasnt CLOSED
   write "You can't lock " noun1{the} " while "
   if noun1 has PLURAL
      write "they are"
   else
      write "it is"
   endif
   write " open.^"
   set time = false
   return true
endif
override
write "You can't lock " noun1{the} " with " noun2{the} .^
set time = false
}

grammar unlock >unlock_only

{+unlock_only
write "What did you want to unlock?^"
setstring question "unlock "
set time = false
}

grammar unlock *present >unlock

{+unlock
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if noun1 hasnt LOCKABLE
   write "You can't unlock " noun1{the} .^
   set time = false
   return true
endif
if +reach<noun1 = true
   return true
endif
if noun1 hasnt LOCKED
   write noun1{The} " " noun1{is} " already unlocked.^"
   set time = false
   return true
endif
override
write "What did you want to unlock " noun1{the} " with?^"
setstring question "unlock " noun1{names} " with "
set time = false
}

grammar unlock *present with *held    >unlock_with
grammar open *present with *held      >unlock_with

{+unlock_with
if +not_held<noun2 = true
   return
endif
if noun1 hasnt LOCKABLE
   write "You can't unlock " noun1{the} .^
   set time = false
   return true
endif
if +reach<noun1 = true
   return true
endif
if noun1 hasnt LOCKED
   write  noun1{The} " " noun1{is} " already unlocked.^"
   return true
endif
override
write "You can't unlock " noun1{the} " with " noun2{the} .^
set time = false
}

grammar show *held	>show

{+show
write "Who did you want to show " noun1{the} " to?^"
setstring question "show " noun1{names} " to "
set time = false
}

grammar show *held to *present        >show_to

{+show_to
if +important<noun2 = true
   return true
endif
if +not_held<noun1 = true
   return
endif
if +darkness = true
   return true
endif
if noun1 = noun2
   write "You can't show " noun1{the} " to "
   if noun1 has PLURAL
     write "themselves."
   else
      write "itself.^"
   endif
   set time = false
   return true
endif
override
write noun2{The} " " noun2{doesnt} " seem overly impressed by " 
write noun1{the} .^
}

grammar untie	>untie_only
grammar free	>untie_only
grammar undo	>untie_only

{+untie_only
write "What did you want to untie?^"
setstring question "untie "
set time = false
}

grammar untie *present        >untie
grammar free *present         >untie
grammar undo *present         >untie

{+untie
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
write  noun1{The} " " noun1{is} " not tied to anything.^"
set time = false
}

grammar tie *held     >tie
grammar attach *held  >tie

{+tie
if +important<noun1 = true
   return true
endif
if +not_held<noun1 = true
   return
endif
if +darkness = true
   return true
endif
write "What do you want to tie " noun1{the} " to?^"
setstring question "tie " noun1{names} " to "
set time = false
}

grammar fix *present	>repair
grammar repair *present	>repair

{+repair
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
write "You are unsure how to repair " noun1{the} ".^"
set time = false
}

grammar tie *held to *present         >tie_to
grammar fix *held to *present         >tie_to
grammar attach *held to *present      >tie_to

{+tie_to
if +important<noun2 = true
   return true
endif
if +not_held<noun1 = true
   return
endif
if +darkness = true
   return true
endif
if +reach<noun2 = true
   return true
endif
override
write "You can't tie " noun1{the} " to " noun2{the} .^
set time = false
}

grammar attack *present       >attack
grammar hit *present          >attack
grammar fight *present        >attack
grammar kill *present         >attack
grammar murder *present       >attack
grammar punch *present        >attack

{+attack
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
ifall noun1 has ANIMATE : noun1 has DEAD
   write  noun1{The} " " noun1{is} " already dead.^"
   set time = false
   return true
endif
override
write "Attacking " noun1{the} " with your hands would have little "
write "effect.^"
set time = false
}

grammar attack *present with *held	>attack_with
grammar hit *present with *held		>attack_with
grammar fight *present with *held	>attack_with
grammar kill *present with *held	>attack_with
grammar murder *present with *held	>attack_with
grammar stab *present with *held	>attack_with
grammar poke *present with *held	>attack_with
grammar break *present with	*held	>attack_with
grammar smash *present with *held	>attack_with
grammar crush *present with *held	>attack_with
grammar destroy *present with *held	>attack_with
grammar wreck *present with *held	>attack_with


{+attack_with
if +important<noun1 = true
   return true
endif
if +not_held<noun2 = true
   return
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
if noun2 has LIQUID
   write  noun2{The} " run" noun2{s} " through your fingers.^"
   return true
endif
ifall noun1 has ANIMATE : noun1 has DEAD
   write  noun1{The} " " noun1{is} " already dead.^"
   set time = false
   return true
endif
if +worn<noun1 = true
   return true
endif
override
write "Attacking " noun1{the} " with " noun2{the} " would have little "
write "effect.^"
set time = false
}

grammar wave  >wave

{+wave
write "You wave your arms around a bit.^"
}

grammar wave to *present      >wave_to

{+wave_to
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if noun1 hasnt ANIMATE
   write "Not surprisingly, you get no response.^"
   return true
endif
write  noun1{The} " barely raises an eye brow.^"
}

grammar salute 	>salute

{+salute
print:
   You fire off one of your snappiest saltues.^
.
}

grammar salute *present		>salute_at
grammar salute at *present	>salute_at
grammar salute to *present	>salute_at

{+salute_at
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if noun1 hasnt ANIMATE
   write "Not surprisingly, you get no response.^"
   return true
endif
override
write "You salute " noun1{the} ".^"
}

grammar jump on to *here >jump_on
grammar jump on *here    >jump_on
grammar hop on *here     >jump_on
grammar stand on *here   >jump_on

{+jump_on
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if noun1 is *held
   write "Is is hard to jump on something while you are holding it.^"
   set time = false
   return
endif
set time = false
if noun1 hasnt SURFACE
   write "You can't jump on " noun1{the} .^
   return true
endif
write "That would achieve little.^"
}

grammar jump over *here       >jump_over

{+jump_over
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if noun1 is *held
   write "Is is hard to jump over something while you are holding it.^"
   set time = false
   return
endif
override
write "You can't jump over " noun1{the} .^
set time = false
}

grammar jump             >jump

{+jump
if here has MID_AIR
   write "Not likely."
   return true
endif
if here has TIGHT_ROPE
   write "Something tells me that might be a bit too dangerous, not to "
   write "mention totally unnecessary.^"
   return true
endif
if here has UNDER_WATER : here has ON_WATER
   write "While underwater?^"
   return true
endif
if player has SITTING
   write "You would have to get up first.^"
   return true
endif
write "Consider it done.^"
}

grammar say yes >yes
grammar yes   	>yes
grammar okay  	>yes
grammar yeah  	>yes

{+yes
write "That was a rhetorical question.^"
set time = false
}

grammar say no	>no
grammar nah 	>no
grammar no		>no
grammar no way	>no

{+no
write "That was a rhetorical question.^"
set time = false
}

grammar say yes to *present 	>say_yes
grammar yes to *present  		>say_yes
grammar say okay to *present 	>say_yes
grammar say yeah to *present 	>say_yes
grammar *present comma yes		>say_yes
grammar *present comma okay		>say_yes
grammar *present comma yeah		>say_yes
grammar *present comma okay		>say_yes

{+say_yes
if +can_talk<noun1 = true
   return true
endif
override
write  noun1{The} " appear" noun1{s} " to pay no attention.^"
}

grammar say no to *present	>say_no
grammar nah to *present 	>say_no
grammar no to *present		>say_no
grammar no way to *present	>say_no
grammar *present comma no	>say_no

{+say_no
if +can_talk<noun1 = true
   return true
endif
override
write  noun1{The} " appear" noun1{s} " to pay no attention.^"
}

grammar say *anywhere >say_object

{+say_object
if here has UNDER_WATER
   write "Talking under water isn't very easy.^"
   set time = false
   return true
endif
override
write "You say, ~" noun1{the} ".~^"
}

grammar say *anywhere to *present	>say_object_to

{+say_object_to
execute "+can_talk<noun2"
override
write "You say, ~" noun1{the} "~ to " noun2{the} ".^"
}

grammar why   >why
grammar why?  >why

{+why
write "Because.^"
set time = false
}

grammar blow *held at *present   >blow_at
grammar blow *held to *present   >blow_at

{+blow_at
if +important<noun2 = true
   return true
endif
if +not_held<noun1 = true
   return
endif
if +darkness = true
   return true
endif
write "You can't blow " noun1{the} " at " noun2{the} .^
set time = false
}

grammar point *held at *present	>point_at
grammar aim *held at *present	>point_at

{+point_at
if +important<noun2 = true
   return true
endif
if +not_held<noun1 = true
   return
endif
if +darkness = true
   return true
endif
if +move_scenery<noun1 = true
   return true
endif
if +worn<noun1 = true
   return true
endif
override
if noun2 has ANIMATE
   write noun2{The} " looks at you quizzically.^"
   return true
endif
write "You point " noun1{the} " at " noun2{the} ".^"
}

grammar throw *held in *here	>throw_at
grammar hurl *held in *here		>throw_at
grammar pitch *held in *here	>throw_at
grammar cast *held in *here		>throw_at
grammar throw *held on *here	>throw_at
grammar hurl *held on *here		>throw_at
grammar pitch *held on *here	>throw_at
grammar cast *held on *here		>throw_at
grammar throw *held at *here	>throw_at
grammar throw *held to *here	>throw_at
grammar cast *held to *here		>throw_at
grammar cast *held at *here		>throw_at
grammar pitch *held to *here	>throw_at
grammar pitch *held at *here	>throw_at
grammar lob *held to *here		>throw_at
grammar lob *held at *here		>throw_at
grammar hurl *held to *here		>throw_at
grammar hurl *held at *here		>throw_at

{+throw_at
if +important<noun2 = true
   return true
endif
if +not_held<noun1 = true
   return
endif
if +darkness = true
   return true
endif
if noun2 has LOCATION
   write noun1{The} " comes to rest nearby.^"
   move noun1 to here
   return
endif
if noun2 is *held
   write "Is is hard to throw anything at " noun2{the} " while you are "
   write "holding " noun2{obj} ".^"
   set time = false
   return
endif
if noun2(parent) hasnt LOCATION
   write "You can't throw " noun1{the} " at " noun2{the} " while "
   if noun2 has PLURAL
      write "they are"
   else
      write "it is"
   endif
   write " in something else.^"
   set time = false
   return true
endif
if +move_scenery<noun1 = true
   return true
endif
if +worn<noun1 = true
   return true
endif
override
if noun2 has ANIMATE
   write "I don't think " noun2{the} " would really appreciate you throwing "
   write noun1{the} " at "
   if noun2 has FEMALE
      write "her.^"
   else
      write "him.^"
   endif
   set time = false
   return true
endif
if noun1(mass) => 20
   write noun1{The}
   if noun1 has PLURAL
     write " are "
   else
     write " is "
   endif
   write "a bit too heavy to go throwing around.^"
   set time = false
   return true
endif
if here has UNDER_WATER
   write "Throwing things underwater is never as easy as you might "
   write "think.^"
   set time = false
   return true
endif
if here has ON_WATER
   write "You throw " noun1{the} " at " noun2{the} " which "
   if noun1 has PLURAL
      write "they bounce"
   else
      write "it bounces"
   endif
   write " off, landing in the water where "
   if noun1 has PLURAL
      write "they"
   else
      write "it"
   endif
   write " rapidly sink" noun1{s} ", disappearing from sight.^"
   move noun1 to limbo
   return true
endif
write  noun1{The} " bounce" noun1{s} " off " noun2{the} " and land" noun1{s}
write " on the ground.^"
move noun1 to here
}

grammar remove **held       >remove
grammar take off **held     >remove
grammar doff **held         >remove

{+remove
ifall noun1(parent) has CONTAINER : noun1 isnt *held
   proxy "take " noun1{names}
   return
endif
if noun1 hasnt WORN : noun1 isnt *held
   write "You are not wearing " noun1{the} .^
   set time = false
   return true
endif
if noun1(mass) > player(quantity)
   write "You are carrying too much to remove " noun1{the} .^
   set time = false
   return true
endif
override
set player(quantity) - noun1(mass)
ensure noun1 hasnt WORN
write "You remove " noun1{the} .^
}

grammar wear **held		>wear
grammar put on **held	>wear
grammar put **held on	>wear
grammar don **held		>wear

{+wear
if +not_held<noun1 = true
   return
endif
if noun1 hasnt WEARABLE
   write "You can't wear " noun1{the} .^
   set time = false
   return true
endif
if noun1 has WORN
   write "You are already wearing " noun1{the} .^
   set time = false
   return true
endif
override
set player(quantity) + noun1(mass)
ensure noun1 has WORN
write "You put " noun1{the} " on.^"
}

grammar talk		>talk_only
grammar talk to		>talk_only
grammar talk with	>talk_only

{+talk_only
if +get_animate != 0
   proxy "talk to " candidate{names}
   return
endif
write "Who did you want to talk to?^"
setstring question "talk to "
set time = false
}

grammar talk *present		>talk_to
grammar talk to *present	>talk_to
grammar talk with *present	>talk_to

{+talk_to
if +can_talk<noun1 = true
   return true
endif
override
write  noun1{The} " " noun1{doesnt} " appear very interested in a "
write "conversation.^"
}

grammar consume *present	>eat
grammar eat *present		>eat

{+eat
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
write "You can't eat " noun1{the} .^
set time = false
}

grammar eat	>eat_only

{+eat_only
write "What did you want to eat?^"
setstring question "eat "
set time = false
}

grammar drink from *present   >drink_from
grammar sip from *present     >drink_from

{+drink_from
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +contains_liquid?<noun1 = true
   proxy "drink " CHILD{names}
   set time = false
   return true
endif
write "There is nothing to drink in " noun1{the} .^
set time = false
}

grammar drink *present        >drink
grammar sip *present          >drink

{+drink
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
if noun1 hasnt LIQUID
   write "You can't drink " noun1{the} .^
   set time = false
   return true
endif
override
write "You drink " noun1{the} .^
move noun1 to limbo
}

grammar drink	>drink_only

{+drink_only
write "What did you want to drink?^"
setstring question "drink "
set time = false
}

grammar flick **present >flick
grammar flip **present >flick

{+flick
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
if noun1 has LIQUID
   write "A wet hand is your only reward.^"
   return true
endif
override
write "Flicking " noun1{the} " achieves nothing more than causing a sharp "
write "pain in your index finger.^"
}

grammar press **present        >press
grammar poke **present         >press

{+press
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
if noun1 has LIQUID
   write "A wet hand is your only reward.^"
   return true
endif
override
write "Pressing " noun1{the} " has no discernible effect.^"
}

grammar light *present with *held     >light_with
grammar burn *present with *held      >light_with
grammar ignite *present with *held    >light_with
grammar set fire to *present with *held >light_with

{+light_with
if +not_held<noun2 = true
   return
endif
if here has UNDER_WATER
   write "I don't think you are going to be lighting anything under "
   write "water.^"
   set time = false
   return true
endif
if +reach<noun1 = true
   return true
endif
if noun1 hasnt FLAMMABLE
   write  noun1{The} " " noun1{is} " not at all flammable.^"
   set time = false
   return true
endif
if noun2 hasnt IGNITABLE
   write "I don't see how you can light " noun1{the} " using " noun2 .^
   set time = false
   return true
endif
if noun1(quantity) = 0
   write  noun1{The} " has run out.^"
   return true
endif
if noun1 has BURNING
   write  noun1{The} " " noun1{is} " already lit.^"
   set time = false
   return true
endif
override
write "You light " noun1{the} " using " noun2 .^
ensure noun1 has BURNING
ensure noun1 has LUMINOUS
}

grammar set *present to $integer	>set_to_integer
grammar turn *present to $integer	>set_to_integer

{+set_to_integer
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
write "You can't set " noun1{the} " to anything.^"
set time = false
}

grammar set *present to $integer with *held >set_to_integer_with
grammar turn *present to $integer with *held >set_to_integer_with

{+set_to_integer_with
if +important<noun1 = true
   return true
endif
if +not_held<noun2 = true
   return
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
write "You can't set " noun1{the} " with " noun2{the} "^"
}

grammar burn *present         >light
grammar light *present        >light
grammar ignite *present       >light
grammar set fire to *present  >light

{+light
if here has UNDER_WATER
   write "I don't think you are going to be lighting anything under "
   write "water.^"
   set time = false
   return true
endif
if +reach<noun1 = true
   return true
endif
if noun1 has IGNITABLE
   override
   write "You produce a brief flame.^"
   return true
endif
if noun1 hasnt FLAMMABLE
   write  noun1{The} " " noun1{is} " not at all flammable.^"
   set time = false
   return true
endif
if noun1 has BURNING
   write  noun1{The} " " noun1{is} " already alight.^"
   set time = false
   return true
endif
write "What did you intent to light " noun1{the} " with?^"
setstring question "light " noun1{names} " with "
set time = false
}

grammar extinguish *present   >extinguish
grammar put out *present      >extinguish

{+extinguish
if noun1 hasnt BURNING
   write  noun1{The} " " noun1{is} " not lit.^"
   set time = false
   return true
endif
if +reach<noun1 = true
   return true
endif
override
write "You put out " noun1{the} .^
ensure noun1 hasnt BURNING
ensure noun1 hasnt LUMINOUS
}

{+sitting
if player has SITTING
   proxy "stand up"
   write "^"
endif
if player has SITTING
   write "You can't move while you are sitting down!^"
   set time = false
   return true
endif
return false
}

integer from_location 0

{+travel
set compass = arg[0]
if compass < 0 : compass > 11
   write "ERROR: Unable to move in direction: " compass ".^"
   return
endif
set destination = here(compass)
ifexecute "+movement"
   # THE MOVE HAS BEEN STOPPED, JUST RETURN
   set time = false
   return
endif
ifexecute "here.movement"
   # THE MOVE HAS BEEN STOPPED, JUST RETURN
   set time = false
   return
endif
if destination = 0
   write "You can't go that way.^"
   set time = false 
else
   # COULD WE OUTPUT A DATA TAG HERE TO TELL THE INTERFACE
   # A SUCESSFUL MOVE HAS TAKEN PLACE?
   set from_location = here
   set player(parent) = destination
   execute "+display_location"
   set time = true
endif
}

grammar swim >swim_only

{+swim_only
if here has UNDER_WATER : here has ON_WATER
   write "You must specify which direction you would like to swim in.^"
   set time = false
   return
endif
write "You can't swim here.^"
set time = false
}

grammar swim west >swim_west

{+swim_west
if here has UNDER_WATER : here has ON_WATER
   execute "+travel<west"
   return true
endif
write "I don't see how you can swim when you are not in water.^"
set time = false
}

grammar west      >west
grammar go west   >west
grammar walk west >west

{+west
if +sitting = true
   return true
endif
override
execute "+travel<west"
}

grammar swim east >swim_east

{+swim_east
if here has UNDER_WATER : here has ON_WATER
   execute "+travel<east"
   return true
endif
write "I don't see how you can swim when you are not in water.^"
set time = false
}

grammar east      >east
grammar go east   >east
grammar walk east >east

{+east
if +sitting = true
   return true
endif
override
execute "+travel<east"
}

grammar swim south >swim_south

{+swim_south
if here has UNDER_WATER : here has ON_WATER
   execute "+travel<south"
   return true
endif
write "I don't see how you can swim when you are not in water.^"
set time = false
}

grammar south      >south
grammar go south   >south
grammar walk south >south

{+south
if +sitting = true
   return true
endif
override
execute "+travel<south"
}

grammar swim southeast >swim_southeast

{+swim_southeast
if here has UNDER_WATER : here has ON_WATER
   execute "+travel<southeast"
   return true
endif
write "I don't see how you can swim when you are not in water.^"
set time = false
}

grammar southeast      >southeast
grammar go southeast   >southeast
grammar walk southeast >southeast

{+southeast
if +sitting = true
   return true
endif
override
execute "+travel<southeast"
}

grammar swim southwest >swim_southwest

{+swim_southwest
if here has UNDER_WATER : here has ON_WATER
   execute "+travel<southwest"
   return true
endif
write "I don't see how you can swim when you are not in water.^"
set time = false
}

grammar southwest      >southwest
grammar go southwest   >southwest
grammar walk southwest >southwest

{+southwest
if +sitting = true
   return true
endif
override
execute "+travel<southwest"
}

grammar swim north >swim_north

{+swim_north
if here has UNDER_WATER : here has ON_WATER
   execute "+travel<north"
   return true
endif
write "I don't see how you can swim when you are not in water.^"
set time = false
}

grammar north         >north
grammar go north      >north
grammar walk north    >north

{+north
if +sitting = true
   return true
endif
override
execute "+travel<north"
}

grammar swim northeast >swim_northeast

{+swim_northeast
if here has UNDER_WATER : here has ON_WATER
   execute "+travel<northeast"
   return true
endif
write "I don't see how you can swim when you are not in water.^"
set time = false
}

grammar northeast             >northeast
grammar go northeast          >northeast
grammar walk northeast        >northeast

{+northeast
if +sitting = true
   return true
endif
override
execute "+travel<northeast"
}

grammar swim northwest >swim_northwest

{+swim_northwest
if here has UNDER_WATER : here has ON_WATER
   execute "+travel<northwest"
   return true
endif
write "I don't see how you can swim when you are not in water.^"
set time = false
}

grammar northwest             >northwest
grammar go northwest          >northwest
grammar walk northwest        >northwest

{+northwest
if +sitting = true
   return true
endif
override
execute "+travel<northwest"
}

grammar climb *here			>climb_up
grammar climb up *here		>climb_up
grammar walk up *here		>climb_up
grammar go up *here			>climb_up

{+climb_up
if noun1 is *held
   write "Is is hard to climb up " noun{2}{the} " while you are "
   write "holding it.^"
   set time = false
   return
endif
override
write "You can not climb up " noun1{the} .^
set time = false
}

grammar climb down *here      >climb_down
grammar walk down *here       >climb_down
grammar go down *here         >climb_down

{+climb_down
if noun1 is *held
   write "Is is hard to climb down " noun{2}{the} " while you are "
   write "holding it.^"
   set time = false
   return
endif
override
write "You can not climb down " noun1{the} .^
set time = false
}

grammar enter *present		>enter
grammar go through *present	>enter
grammar go thru *present	>enter
grammar go in *present		>enter
grammar climb on *present	>enter
grammar climb in *present	>enter
grammar get in *present		>enter
grammar jump in *present	>enter
grammar get on *present		>enter

{+enter
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
write "You can't enter " noun1{the} .^
set time = false
}

integer NEARBY

grammar follow *anywhere	>follow

{+follow
if noun1 is *present
   write noun1{The} " is right here!^"
   set time = false
   return
endif

set INDEX = -1

# LOOP THROUGH ALL THE EXITS OF THE CURRENT LOCATION
set COUNTER = 0
repeat
   if here(COUNTER) = noun1(parent)
      set INDEX = COUNTER
   endif
   set COUNTER + 1
until COUNTER = 12

if INDEX != -1
   execute "+go_direction<INDEX"
else
   write "You aren't sure which way to go.^"
   set time = false
endif
}

grammar go back		>go_back
grammar back		>go_back
grammar return		>go_back

{+go_back
if from_location != 0
   proxy "go to " from_location{names}
   return true
endif
write "You need to go somewhere first!^"
set time = false
}

grammar head to *location		>go_to
grammar head towards *location	>go_to
grammar head over to *location	>go_to
grammar head down to *location	>go_to
grammar head up to *location	>go_to
grammar report to *location		>go_to
grammar move to *location		>go_to
grammar walk to *location		>go_to
grammar go up to *location		>go_to
grammar go down to *location	>go_to
grammar go over to *location	>go_to
grammar go to *location			>go_to
grammar go *location			>go_to

{+go_to
if noun1 = here
   write "You are already there!^"
   set time = false
   return
endif
dir_to INDEX here noun1
if INDEX = -1
   write "You aren't sure which way to go.^"
   set time = false
   return
endif
write "] "
style input
write dir_command[INDEX] ^
style normal
execute "+go_direction<INDEX"
}

{+go_direction
if arg[0] = north
   proxy "go north"
   return true
endif
if arg[0] = northeast
   proxy "go northeast"
   return true
endif
if arg[0] = east
   proxy "go east"
   return true
endif
if arg[0] = southeast
   proxy "go southeast"
   return true
endif
if arg[0] = south
   proxy "go south"
   return true
endif
if arg[0] = southwest
   proxy "go southwest"
   return true
endif
if arg[0] = west
   proxy "go west"
   return true
endif
if arg[0] = northwest
   proxy "go northwest"
   return true
endif
if arg[0] = up
   proxy "go up"
   return true
endif
if arg[0] = down
   proxy "go down"
   return true
endif
if arg[0] = in
   proxy "go in"
   return true
endif
if arg[0] = out
   proxy "go out"
   return true
endif
}

grammar swim in >swim_in

{+swim_in
if here has UNDER_WATER : here has ON_WATER
   execute "+travel<in"
   return true
endif
write "I don't see how you can swim when you are not in water.^"
set time = false
}

grammar go in		>in
grammar get in		>in
grammar climb in	>in
grammar in			>in
grammar enter		>in
grammar walk in		>in

{+in
if +sitting = true
   return true
endif
override
execute "+travel<in"
}

grammar swim out >swim_out

{+swim_out
if here has UNDER_WATER : here has ON_WATER
   execute "+travel<out"
   return true
endif
write "I don't see how you can swim when you are not in water.^"
set time = false
}

grammar get out		>out
grammar out			>out
grammar exit		>out
grammar leave		>out
grammar climb out	>out
grammar walk out	>out
grammar go out		>out

{+out
if +sitting = true
   return true
endif
override
execute "+travel<out"
}

grammar surface >swim_up
grammar swim up >swim_up

{+swim_up
if here has UNDER_WATER : here has ON_WATER
   execute "+travel<up"
   return true
endif
write "I don't see how you can swim when you are not in water.^"
set time = false
}

grammar up            >up
grammar climb         >up
grammar climb up      >up
grammar jump up       >up
grammar go up         >up
grammar walk up       >up

{+up
if +sitting = true
   return true
endif
override
execute "+travel<up"
}

grammar swim down     >swim_down
grammar dive down     >swim_down
grammar dive          >swim_down

{+swim_down
if here has UNDER_WATER : here has ON_WATER
   execute "+travel<down"
   return true
endif
write "I don't see how you can swim when you are not in water.^"
set time = false
}

grammar down          >down
grammar climb down    >down
grammar jump down     >down
grammar go down       >down
grammar walk down     >down

{+down
if +sitting = true
   return true
endif
override
execute "+travel<down"
}

grammar look around	>look_around
grammar look		>look_around
grammar ls			>look_around
grammar watch		>look_around

{+look_around
ensure here hasnt VISITED
execute "+display_location"
set time = false
}

{+display_location
ifexecute "+before_look"
  return
endif
ifexecute "here.before_look"
  return
endif
if here has DARKNESS
   execute "+no_light"
   return
endif
call "+title"
if display_mode = true
   ensure here hasnt VISITED
endif
ifexecute "here.look"
   # THERE IS A LOCATION SPECIFIC LOOK FUNCTION,
   # NO NEED TO PERFORM THE DEFAULT ACTION
else
   execute "+look"
endif
ensure here has KNOWN
ensure here has VISITED
ensure here has MAPPED
execute "+object_descriptions"
call "here.after_look"
call "+after_look"
}

{+look
write "You can see "
set INDEX = 0
loop
   ifall here grandof noun3 : player !grandof noun3 : noun3 hasnt LOCATION
      set INDEX + 1
   endif
endloop
if INDEX = 0
   write "nothing special.^"
   return true
endif
loop
   ifall here grandof noun3 : player !grandof noun3 : noun3 hasnt LOCATION
      set INDEX - 1
      write noun3{list}
      execute "+object_info<noun3"
      execute "+list_structure"
      if INDEX = 0
         write "^"
         return true
      endif
   endif
endloop
}

{+object_descriptions
select here
   ifall noun3(mass) < scenery : noun3 hasnt LOCATION
      write ^ noun3{long}
   endif
endselect
}

{+no_light
write "It is too dark to see.^"
}

grammar look under *present		>look_under
grammar search under *present	>look_under

{+look_under
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if noun1(mass) >= heavy : noun1 has LOCATION
   write "You can't see under " noun1{the} .^
   set time = false
   return true
endif
write "There is nothing unusual under " noun1{the} .^
}

grammar look behind *present	>look_behind
grammar search behind *present	>look_behind

{+look_behind
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if noun1(mass) >= heavy : noun1 has LOCATION
   write "You can't see behind " noun1{the} .^
   set time = false
   return true
endif
write "There is nothing unusual behind " noun1{the} .^
}

grammar look through *present	>look_through
grammar look thru *present		>look_through
grammar look out *present		>look_through

{+look_through
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
write "You can't look through " noun1{the} .^
set time = false
}

grammar look through *held at *present	>look_through_at
grammar look thru *held at *present		>look_through_at

{+look_through_at
proxy "look at " noun2{names} " through " noun1{names}
}

grammar look at *present through *held	>look_at_through
grammar look at *present thru *held		>look_at_through
grammar look at *present with *held		>look_at_through

{+look_at_through
if +important<noun1 = true
   return true
endif
if +not_held<noun2 = true
   return
endif
if +darkness = true
   return true
endif
if noun1 = noun2
   write "You can't look at " noun1{the} " through "
   if noun1 has PLURAL
      write "themselves.^"
   else
      write "itself.^"
   set time = false
   return true
endif
override
write "You can't look at " noun1{the} " through " noun2{the} .^
set time = false
}

grammar wait				>wait
grammar z					>wait

{+wait
write "Time passes...^"
}

grammar listen        >listen

{+listen
override
write "You don't hear anything out of the ordinary.^"
}

grammar listen to *present    >listen_to
grammar listen at *present    >listen_to

{+listen_to
write "You don't hear anything out of the ordinary.^"
}

grammar use *present          >use
grammar work *present         >use
grammar operate *present      >use

{+use
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if noun1 has ANIMATE
   write "I acknowledge that I probably don't want to know the answer to "
   write "this question, but in what way did you want to use " noun1{the} .^
   set time = false
   return true
endif
write "I'm afraid you are going to have to be a bit more specific "
write "about how you want to use " noun1{the} ".^"
}

grammar rotate *present		>turn
grammar turn *present		>turn
grammar twist *present		>turn
grammar twiddle *present	>turn
grammar spin *present		>turn

{+turn
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
write "You can't turn " noun1{the} .^
set time = false
}

grammar rotate *present clockwise	>turn_clockwise
grammar turn *present clockwise		>turn_clockwise
grammar twist *present clockwise 	>turn_clockwise
grammar twiddle *present clockwise	>turn_clockwise
grammar spin *present clockwise		>turn_clockwise

{+turn_clockwise
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
write "You can't turn " noun1{the} " clockwise.^"
set time = false
}

grammar rotate *present anticlockwise	>turn_anticlockwise
grammar turn *present anticlockwise		>turn_anticlockwise
grammar twist *present anticlockwise 	>turn_anticlockwise
grammar twiddle *present anticlockwise	>turn_anticlockwise
grammar spin *present anticlockwise		>turn_anticlockwise

{+turn_anticlockwise
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
write "You can't turn " noun1{the} " anticlockwise.^"
set time = false
}

grammar engage *present		>turn_on
grammar turn on *present	>turn_on
grammar activate *present	>turn_on
grammar turn *present on	>turn_on
grammar switch on *present	>turn_on
grammar switch *present on	>turn_on
grammar start *present		>turn_on

{+turn_on
if +reach<noun1 = true
   return true
endif
override
if noun1 has ON
   write  noun1{The} " " noun1{is} " already on.^"
else
   write "You can't turn " noun1{the} " on.^"
endif
set time = false
}

grammar disengage *present	>turn_on
grammar turn off *present	>turn_off
grammar turn *present off	>turn_off
grammar shut down *present	>turn_off
grammar power down *present	>turn_off
grammar shut off *present	>turn_off
grammar power off *present	>turn_off
grammar switch off *present	>turn_off
grammar switch *present off	>turn_off
grammar stop *present		>turn_off

{+turn_off
if +reach<noun1 = true
   return true
endif
override
write "You can't turn " noun1{the} " off.^"
set time = false
}

grammar pour *present         >pour

{+pour
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if noun1 hasnt LIQUID
   write "You can't pour " noun1{the} .^
   set time = false
   return true
endif
set noun3 = noun1(parent)
if noun3 = false : noun3(parent) <> player
   write "You don't have " noun1{the} .^
   set time = false
   return true
endif
if +closed<noun3 = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
write "You pour " noun1{the} " all over the ground.^"
move noun1 to limbo
}

grammar type $string on *present >type_on
grammar write $string in *present >type_on

{+type_on
if +important<noun1 = true
   return true
endif
if +darkness = true
   return true
endif
if +reach<noun1 = true
   return true
endif
override
write "You can't type on " noun1{the} ".^"
set time = false
}

grammar list objects >list_objs

{+list_objs
select noun3(mass) > 0 
   write noun3{The} 
next
}

grammar tip *present on *present      >pour_on
grammar tip *present down *present    >pour_on
grammar tip *present in *present      >pour_on
grammar tip *present over *present    >pour_on
grammar pour *present down *present   >pour_on
grammar pour *present on *present     >pour_on
grammar pour *present in *present     >pour_on
grammar pour *present over *present   >pour_on

{+pour_on
if +important<noun1 = true
   return true
endif
if +important<noun2 = true
   return true
endif
if +darkness = true
   return true
endif
if noun1 hasnt LIQUID
   write "You can't pour " noun1{the} .^
   set time = false
   return true
endif
if +reach<noun1 = true
   return true
endif
set noun3 = noun1(parent)
if noun3 = false : noun3(parent) <> player
   write "You do not have " noun1{the} .^
   set time = false
   return true
endif
if +closed<noun3 = true
   return true
endif
if +closed<noun2 = true
   return true
endif
if +reach<noun2 = true
   return true
endif
override
if +contains_liquid?<noun2 = true
   write noun2{The} " already contain" noun2{s} " " CHILD{the} ". If you "
   write "were to also add " noun1{the} " they would mix together.^"
   set time = false
   return true
endif
ifall noun2 has CONTAINER : noun2 hasnt CLOSED
   override
   write "You pour " noun1{the} " into " noun2{the} .^
   move noun1 to noun2
   return true
endif
ifall noun2(parent) hasnt LOCATION : noun2(parent) has CONTAINER
   set noun3 = noun2(parent)
   write noun1{The} " run" noun1{s} " off " noun2{the} " and goes into "
   write noun3{the} ".^"
   move noun1 to noun3
   return true
endif
write noun1{The} " runs off " noun2{the} " and goes all over the "
write "ground.^"
move noun1 to limbo
}

grammar blankjacl >blankjacl

{+blankjacl
write "A fiendishly clever move.^"
set time = false
}

grammar instructions	>instructions
grammar help		>instructions

{+instructions
print:
   Interactive fiction involves the reader in a way that static stories
   do not. Rather than reading sequentially from beginning to end, you
   control the actions of the main character by typing commands in the
   form of simple English sentences. Before setting out on your adventure
   there are a few concepts that must be explained in order for you to
   interact successfully with the virtual world created by the author.^^
   The physical space that you will be exploring is divided up into
   discrete units called locations. Locations may be travelled between
   using the following commands:^^
.
style preformatted
set linebreaks = false
print:
   ||n  for north^
   ||s  for south^
   ||e  for east^
   ||w  for west^
   ||ne for northeast^
   ||nw for northwest^
   ||se for southeast^
   ||sw for southwest^ 
   ||u  for up^
   ||d  for down^^
.
style normal
set linebreaks = true
print:
   The description of each location will tell you which way you can
   move from it. Be aware however that some exits may only be
   available under certain circumstances such as while a door is open
   or a bridge lowered.^^
   Within these locations you will find many objects that you may
   manipulate. These objects may be referred to by as few
   or as many of their names as is required to uniquely identify it.
   For example, if the story informs you that ~There is a silver key
   resting here.~ Then it may be referred to as either ~silver~, ~key~ or
   ~silver key~. If your reference is ambiguous, such as using ~key~
   when there is both a silver and a gold key in the current location
   then you will be prompted to be more specific.^^

   The next major concept of interactive fiction to understand is the
   way in which you interact with these objects within
   the locations. The main aspect of the command interface
   to come to grips with is the scale, in other words, how much can be
   achieved with a single command. As you have seen earlier, moving from
   one location to another requires a single command. Commands such as
   ~find dave~ or ~go to the library~ are not valid. You must manually
   move around the available world to achieve these tasks yourself. For
   this reason, making a map as you go is highly recommended.^^
   The basic sentence structures understood by the game are:^
.
style preformatted
set linebreaks = false
print:
   action                            eg. scream ^
   action object                     eg. take book ^
   action object preposition object  eg. unlock door with key ^^
.
style normal
set linebreaks = true
print:
   An action does not necessarily have to be a single word. For instance,
   ~examine rock through magnifying glass~, an example of the last
   syntax, may also be expressed as ~look at rock through magnifying
   glass~.^^
   To further illustrate how much can be achieved in a single turn,
   consider the following list (being just some of the valid actions):^^
.
style preformatted
set linebreaks = false
print:
   turn    read    pull    push    eat    cut^
   lock    unlock  rub     attack  taste  drink^
   break   smell   listen  pour    move   light^
   attack  blow    throw   wear    open   close^
   take    drop    insert  remove^^
   .
style normal
set linebreaks = true

print:
   The words ~it,~ ~them,~ ~him~ and ~her~ may be used to indicate the
   last appropriate object referred to in one of your commands.
   The words ~itself,~ ~themselves,~ ~himself~ and ~herself~ may be used
   to refer to the subject of the current command such as, ~ask dan about
   himself~.^^
   The word ~all~ or ~everything~ may be used in place of an object
   when using one of the verbs in the bottom row of the table above.^^

   However, a task such as defusing a bomb would generally not be achieved by
   typing ~defuse bomb~. The following is a sample transcript to give
   you a better idea of how this task such as this might be achieved.^^
.

set linebreaks = false
style preformatted
print:
> examine bomb^
The bomb is about a foot square and has a small^
panel in its upper surface. The panel is currently^
closed.^^
> listen to bomb^
The bomb is making an ominous ticking sound.^^
>open panel^
You open the panel to reveal a red wire, a green^
wire, a blue wire, a clock and some dynamite.^^
> i^
You are carrying a bomb manual, an insurance^
policy and some wire cutters.^^
> read manual^
Leafing through the book you come to the page on^
diffusing. Seems straight forward enough, just^
cut the blue wire then the red one.^^
> cut blue wire with cutters^
Reaching carefully in to the bomb's casing you^
cut the blue wire. So far so good.^^
> cut red wire with cutters^
Holding your breath you snip the red wire.^^
> listen to bomb^
.
style normal
set linebreaks = true
print:
   The bomb, thankfully, is now silent.^^
   As you can see, each task you wish to achieve must be broken down^
   into its component actions.^^

   During the course of the story you may encounter other computer^
   controlled characters. These characters may be interacted with using^
   the following commands:^^
.
style preformatted
set linebreaks = false
print:
   ||talk to CHARACTER^
   ||give OBJECT to CHARACTER^
   ||show OBJECT to CHARACTER^
   ||ask CHARACTER for OBJECT^
   ||ask CHARACTER about OBJECT^
   ||tell CHARACTER about OBJECT^^
.
style normal
set linebreaks = true
print:
   There are also some special commands for interacting with the
   program rather than the world it simulates:^^
.
style preformatted
set linebreaks = false
print:
   ||Command    Action^^
   ||VERBOSE    always describe locations ^
   ||BRIEF      only describe new locations ^
   ||RESTART    start from the beginning ^
   ||SCORE      display your score and rank ^
   ||LOOK       describe the current location ^
   ||SAVE       save the current position ^
   ||RESTORE    restore a saved position ^
   ||I          horizontal list of possessions ^
   ||INV        vertical list of possessions ^
   ||UNDO       take back last command ^
   ||AGAIN      repeat the last command ^
   ||INFO       display version information ^^
.
style normal
set linebreaks = true
print:
   NOTE: If you are looking for a clue relevant to a specific location,
   type ~hint~, ~first hint~ or ~hint one~ in that location. The first
   hint will be a subtle clue with ~hint two~ being more blatant and
   ~hint three~ being exact commands to type.^^

   You are now ready to embark on your first adventure into the
   world of interactive fiction.
   Remember to make a map as you go and read each
   part carefully as vital clues may be hidden in the descriptions of the
   locations and objects you come across. Examining every object you can
   refer to is a good idea, as is saving your position often. Well, good
   luck, and above all have fun!^
.
set time = false
}

;                                                    SPEAKING TO OTHER OBJECTS
; ----------------------------------------------------------------------------
; Grammar statements beginning with an object must be defined last in the game
; to avoid confusion with verbs that may also be objects such as "drink drink"

grammar *present comma press *present		>tell_to_press
grammar *present comma push *present		>tell_to_press

{+tell_to_press
if +can_talk<noun1 = true
   return true
endif
write "~You press it,~ " noun1{the} " replies.^"
}

grammar *present comma give me *anywhere		>ask_for
grammar *present comma give *anywhere to myself	>ask_for
grammar *present comma give *anywhere to me		>ask_for

grammar *present comma tell me about *anywhere			>ask_about
grammar *present comma tell me all about *anywhere		>ask_about
grammar *present comma what do you know about *anwhere	>ask_about

grammar *present comma who are you		>who?
grammar *present comma what is your name	>who?
grammar *present comma what is your name?	>who?

{+who?
if +can_talk<noun1 = true
   return true
endif
proxy "ask " noun1{names} " about " noun1{names}
}

grammar *present comma sorry		>apologise
grammar *present comma im sorry	>apologise
grammar *present comma i am sorry	>apologise
grammar apologise to *present	>apologise

{+apologise
if +can_talk<noun1 = true
   return true
endif
write  noun1{the} " assure" noun1{s} " you that no apology is "
write "necessary.^"
}

grammar *present comma thanks		>thank
grammar *present comma thank you	>thank
grammar thank *present		>thank

{+thank
if +can_talk<noun1 = true
   return true
endif
write "~Don't mention it,~ "  noun1{the} " replies.^"
}

grammar hi *present					>greet
grammar hello *present				>greet
grammar greet *present				>greet
grammar *present comma hello		>greet
grammar *present comma hello sailor	>greet
grammar *present comma hi there		>greet
grammar *present comma dr			>greet
grammar *present comma doctor		>greet
grammar *present comma hi			>greet

{+greet
if +can_talk<noun1 = true
   return true
endif
override
write  noun1{The}
if noun1 has PLURAL
   write " nod.^"
else
   write " nods.^"
}
 
grammar *present comma *anywhere	>object_object

{+object_object
if +can_talk<noun1 = true
   return true
endif
override
write "You get no response.^"
}

string question			"none"

grammar *present	>noun_only
grammar *anywhere	>noun_only

{+noun_only
ifstring question != "none"
   addstring question noun1{names} 
   proxy question
   return
else
   if noun1 has LOCATION
      write "] "
      style input
      write "go to " noun1{the} ^
      style normal
      proxy "go to " noun1{names}
      return
   endif
   if noun1 isnt *present
      write "You can't see " noun1{the} " here.^"
      set time = false
      return
   endif
   ifall noun1 has ANIMATE : noun1 hasnt DEAD
      write "] "
      style input
      write "talk to " noun1{the} ^
      style normal
      proxy "talk to " noun1{names}
      return
   endif
   ifall noun1(mass) < heavy noun1 : hasnt OUT_OF_REACH : noun1 isnt *held
      write "] "
      style input
      write "take " noun1{the} ^
      style normal
      proxy "take " noun1{names}
      return
   endif
   write "] "
   style input
   write "examine " noun1{the} ^
   style normal
   proxy "examine " noun1{names}
   return
endif
write "There is no verb in that sentence.^"
set time = false
}

{+system_eachturn
setstring question "none"
}

integer candidate

{+get_animate
set INDEX = 0
set candidate = 0
select *present
  ifall noun3 has ANIMATE noun3 != player
     set candidate = noun3
     set INDEX + 1
  endif
endselect
if INDEX = 1
   return candidate
else
   return 0
endif
}

{+get_inanimate
set INDEX = 0
set candidate = 0
select *present noun3
  ifall noun3 hasnt ANIMATE : noun3 is *present : noun3(mass) != scenery
     set candidate = noun3
     set INDEX + 1
  endif
endselect
if INDEX = 1
   return candidate
else
   return 0
endif
}

{+get_openable
set INDEX = 0
set candidate = 0
select *present noun3
  ifall noun3 has CLOSABLE
     set candidate = noun3
     set INDEX + 1
  endif
endselect
if INDEX = 1
   return candidate
endif
if INDEX = 0
   return 0
else
   # THERE ARE MORE THAN ONE, SEE IF IT CAN BE REDUCED BY OPEN LOOKING
   # FOR CLOSED OBJECTS
   set INDEX = 0
   set candidate = 0
   select *present noun3
     ifall noun3 has CLOSABLE : noun3 has CLOSED
        set candidate = noun3
        set INDEX + 1
     endif
   endselect
   if INDEX = 1
      return candidate
   else
      return 0
   endif
endif
}

{+get_closable
set INDEX = 0
set candidate = 0
select *present noun3
  ifall noun3 has CLOSABLE
     set candidate = noun3
     set INDEX + 1
  endif
endselect
if INDEX = 1
   return candidate
endif
if INDEX = 0
   return 0
else
   # THERE ARE MORE THAN ONE, SEE IF IT CAN BE REDUCED BY OPEN LOOKING
   # FOR CLOSED OBJECTS
   set INDEX = 0
   set candidate = 0
   select *present noun3
     ifall noun3 has CLOSABLE : noun3 hasnt CLOSED
        set candidate = noun3
        set INDEX + 1
     endif
   endselect
   if INDEX = 1
      return candidate
   else
      return 0
   endif
endif
}

{+get_takeable
set INDEX = 0
set candidate = 0
select *present noun3
  ifall noun3(mass) < heavy : noun3 isnt *held : noun3 hasnt LOCATION
     set candidate = noun3
     set INDEX + 1
  endif
endselect
if INDEX = 1
   return candidate
else
   return 0
endif
}

{+get_dropable
set INDEX = 0
set candidate = 0
select *held noun3
  if noun3(mass) < heavy
     set candidate = noun3
     set INDEX + 1
  endif
endselect
if INDEX = 1
   return candidate
else
   return 0
endif
}

{+game_over
write "^"
execute "+score"
select player
   set noun3(parent) = limbo
endselect
set player(parent) = epilogue
write "^"
execute "+look_around"
}

location epilogue : epilogue
   short	name "Game Over"

{look
if interpreter = GLK
   write "The game is over. Type "
   style input
   write "undo"
   style normal
   write ", "
   style input
   write "restart"
   style normal
   write " or "
   style input
   write "restore"
   style normal
   write " followed by a filename, or "
   style input
   write "quit"
   style normal
   write ".^"
else
   write "The game is over. Type <b>undo</b>, <b>restart</b> or <b>restore</b> "
   write "followed by a filename.^"
endif
}

{+title
style subheader
write here{The}
style normal
if interpreter != CGI
   write "^"
endif
if here has WITHOUT_AIR
   if tank hasnt WORN
      write "(holding your breath)^"
endall
if player has SITTING
      write "(sitting)^"
endif
}

{+update_top_screen
cursor 1 0
style note
write game_title "^"
style normal
write "------------------------------^"
write "                              ^"
cursor 3 0
write "Score:" score "% Moves: " total_moves "^^"
write "                              ^"
style subheader
cursor 5 0
write here{The} "^^"
style normal
}
